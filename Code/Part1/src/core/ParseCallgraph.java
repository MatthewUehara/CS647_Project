package core;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.TreeSet;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * Parse the callgraph generated by LLVM.
 */
public class ParseCallgraph {
	// REGEX pattern for function name
	public static final Pattern nodePattern = Pattern
			.compile("Call graph node for function: '(.*?)'<<(.*?)>>  #uses=(\\d*).*");
	// REGEX pattern for callsite
	public static final Pattern callsitePattern = Pattern
			.compile("\\s*CS<(.*?)> calls function '(.*?)'.*");

	/**
	 * I don't think we need to overcomplicate things. Java can just perform
	 * Runtime.getRuntime().exec()
	 * 
	 * TODO This is just a rough start.
	 * 
	 * @param args
	 */
	public static void main(String[] args) {
		String currentLine = null;
		String currentNode = null;
		TreeSet<Support> supports = new TreeSet<Support>();

		try {
			Process process = Runtime.getRuntime().exec(
					"opt -print-callgraph ../proj-skeleton/test2/main.bc");

			// Content of BitCode is printed to stdout. Not interesting.
			BufferedReader stdInput = new BufferedReader(new InputStreamReader(
					process.getInputStream()));

			// Call graph is printed to stderr.
			BufferedReader stdError = new BufferedReader(new InputStreamReader(
					process.getErrorStream()));

			// Parse stderr line by line
			while ((currentLine = stdError.readLine()) != null) {
				String currentUID = "";

				// We're at a new node
				Matcher nodeMatcher = nodePattern.matcher(currentLine);
				if (nodeMatcher.find()) {
					currentNode = nodeMatcher.group(1);
					Support support = setupNewNode(currentLine, nodeMatcher);
					supports.add(support);
				}

				// We're at a callsite within currentNode
				Matcher callsiteMatcher = callsitePattern.matcher(currentLine);
				// First node in callgraph is a null function
				// TODO Do we need to evaluate it? TA's tutorial was unclear.
				if (callsiteMatcher.find() && currentNode != null) {
					evaluateSupport(currentLine, callsiteMatcher, currentNode,
							supports);
				}

				System.out.println(currentLine);
			}

			System.out.println("");
			System.out.println("RESULTS:");
			System.out.println("--------");
			for (Support s : supports) {
				System.out.println(s);
			}

			System.exit(0);
		} catch (IOException e) {
			e.printStackTrace();
			System.exit(-1);
		}
	}

	private static void evaluateSupport(String currentLine,
			Matcher callsiteMatcher, String currentNode,
			TreeSet<Support> supports) {
		String calledFunction = callsiteMatcher.group(2);

		TreeSet functions = new TreeSet<String>();
		functions.add(currentNode);
		functions.add(calledFunction);
		Support supportPair = new Support(functions, 1);
		
		System.out.println("Evaluating support of: " + supportPair);

		boolean matched = false;
		for (Support s : supports) {
			if (s.equals(supportPair)) {
				s.incrementCount();
				matched = true;
				break;
			}
		}

		if (!matched) {
			supports.add(supportPair);
		}
	}

	/**
	 * Initialize a TreeSet of size 1 to be the denominator in confidence
	 * measures for that function.
	 * 
	 * @param currentLine
	 * @param nodeMatcher
	 * @return Support object for a single function
	 */
	private static Support setupNewNode(String currentLine, Matcher nodeMatcher) {
		String function = nodeMatcher.group(1);
		String nuid = nodeMatcher.group(2); // node uid?

		// Using total count from LLVM, but may from inter-procedural.
		int count = Integer.parseInt(nodeMatcher.group(3));

		// Setup up a TreeSet of size 1 for the function by itself.
		TreeSet functions = new TreeSet<String>();
		functions.add(function);

		return new Support(functions, count);
	}
}
